package pl.touk.nussknacker.engine.flink.api.process

import org.apache.flink.api.common.typeinfo.TypeInformation
import org.apache.flink.api.scala._
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.functions.source.SourceFunction
import org.apache.flink.streaming.api.scala.{DataStream, StreamExecutionEnvironment}
import pl.touk.nussknacker.engine.api.{Context, MethodToInvoke}
import pl.touk.nussknacker.engine.api.process.{Source, SourceFactory}
import pl.touk.nussknacker.engine.flink.api.compat.ExplicitUidInOperatorsSupport
import pl.touk.nussknacker.engine.flink.api.timestampwatermark.TimestampWatermarkHandler
import pl.touk.nussknacker.engine.flink.util.context.InitContextFunction

import scala.reflect._

/**
  * Source with methods specific for Flink
  * @tparam T - type of event that is generated by this source. This is needed to handle e.g. syntax suggestions in UI
  */
trait FlinkSource[T] extends Source[T] {

  def sourceStream(env: StreamExecutionEnvironment,
                   flinkNodeContext: FlinkCustomNodeContext): DataStream[Context]

}

trait SourceTestSupport[T] { self: Source[T] =>

  //TODO: design better way of handling test data in generic FlinkSource
  //Probably we *still* want to use CollectionSource (and have some custom logic in parser if needed), but timestamps
  //have to be handled here for now
  def timestampAssignerForTest : Option[TimestampWatermarkHandler[T]]

  // We abstracting to stream so theoretically it shouldn't be defined on this level but for test mechanism purpose
  // we need to know what type will be generated.
  def typeInformation: TypeInformation[T]

}

/**
  * Typical source with methods specific for Flink, user has only to define Source
  * @tparam T - type of event that is generated by this source. This is needed to handle e.g. syntax suggestions in UI
  */
trait BasicFlinkSource[T] extends FlinkSource[T] with SourceTestSupport[T] with ExplicitUidInOperatorsSupport {

  def flinkSourceFunction: SourceFunction[T]

  def timestampAssigner : Option[TimestampWatermarkHandler[T]]

  override def timestampAssignerForTest : Option[TimestampWatermarkHandler[T]] = timestampAssigner

  def ctxTypeInformation: TypeInformation[Context] = implicitly[TypeInformation[Context]]

  override def sourceStream(env: StreamExecutionEnvironment, flinkNodeContext: FlinkCustomNodeContext): DataStream[Context] = {

    env.setStreamTimeCharacteristic(if (timestampAssigner.isDefined) TimeCharacteristic.EventTime else TimeCharacteristic.IngestionTime)

    val rawSourceWithUid = setUidToNodeIdIfNeed(flinkNodeContext, env
      .addSource[T](flinkSourceFunction)(typeInformation)
      .name(s"${flinkNodeContext.metaData.id}-${flinkNodeContext.nodeId}-source"))

    val rawSourceWithUidAndTimestamp = timestampAssigner
      .map(_.assignTimestampAndWatermarks(rawSourceWithUid))
      .getOrElse(rawSourceWithUid)

    rawSourceWithUidAndTimestamp
      .map(new InitContextFunction[T](flinkNodeContext.metaData.id, flinkNodeContext.nodeId))(implicitly[TypeInformation[Context]])
  }
}

//Serializable to make Flink happy, e.g. kafkaMocks.MockSourceFactory won't work properly otherwise
abstract class FlinkSourceFactory[T: ClassTag] extends SourceFactory[T] with Serializable {

  def clazz: Class[T] = classTag[T].runtimeClass.asInstanceOf[Class[T]]

}

object FlinkSourceFactory {

  def noParam[T: ClassTag](source: FlinkSource[T]): FlinkSourceFactory[T] =
    new NoParamSourceFactory[T](source)

  case class NoParamSourceFactory[T: ClassTag](source: FlinkSource[T]) extends FlinkSourceFactory[T] {
    @MethodToInvoke
    def create(): Source[T] = source
  }

}
